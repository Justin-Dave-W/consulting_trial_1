import { createRequire as _createRequire } from 'node:module';
const require = _createRequire(import.meta.url);
import {
  getDeployment,
  getDeploymentPipelineDescription,
  publishDeployment
} from "./chunk-LZJPV4CP.js";
import {
  DeploymentPipelinesStatus,
  TaskStatus
} from "./chunk-6XRFJZTQ.js";
import {
  createSiteFsManager
} from "./chunk-KQMZOXQO.js";
import {
  loadProjectRootFiles
} from "./chunk-HGBMRF3C.js";
import {
  useHttpClient,
  useVeloClient
} from "./chunk-E56WW2OA.js";
import {
  GridAppLayout
} from "./chunk-6LI4WGAW.js";
import {
  useProjectModel
} from "./chunk-Q6F4OGQT.js";
import {
  pRetry,
  pWaitFor
} from "./chunk-O25O35J2.js";
import {
  require_react
} from "./chunk-OH3G6JMX.js";
import {
  getTestOverrides,
  z
} from "./chunk-GNB7T7J7.js";
import {
  CliError,
  CliErrorCode,
  require_lib
} from "./chunk-CVJG3VZM.js";
import {
  __toESM,
  init_esm_shims
} from "./chunk-PYIAC2GK.js";

// ../document-management-client/src/document-management-client.ts
init_esm_shims();
var import_variant = __toESM(require_lib(), 1);

// ../document-management-client/src/schemas.ts
init_esm_shims();
var getDeploymentSchema = z.object({
  deployment: z.object({
    deploymentPipelinesStatus: z.enum([
      DeploymentPipelinesStatus.IN_PROGRESS,
      DeploymentPipelinesStatus.SUCCESS,
      DeploymentPipelinesStatus.ERROR
    ])
  })
});
var taskDescriptionSchema = z.object({
  taskName: z.string(),
  status: z.string().transform(
    (value) => value === TaskStatus.SUCCESS ? TaskStatus.SUCCESS : TaskStatus.ERROR
  ),
  description: z.string().nullish().transform((value, ctx) => {
    try {
      return value ? JSON.parse(value) : {};
    } catch {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Invalid JSON"
      });
    }
    return value;
  }).pipe(z.record(z.string(), z.string()))
});
var getDeploymentPipelineDescriptionSchema = z.object({
  pipelinesDescription: z.array(
    z.object({
      deploymentPipelineId: z.string(),
      tasksDescriptions: z.array(taskDescriptionSchema)
    })
  )
});

// ../document-management-client/src/document-management-client.ts
var { minRetryTimeout, pollInterval } = getTestOverrides();
var VELO_PIPELINE_ID = "5c696513-2584-4f19-ae0f-a559dd649482";
var DeploymentStatus = (0, import_variant.variant)({
  Success: {},
  Error: (0, import_variant.fields)()
});
var DocumentManagementClient = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
    this.retryOptions = {
      retries: 1,
      minTimeout: minRetryTimeout,
      maxTimeout: 3 * 1e3
    };
  }
  retryOptions;
  getDeploymentDetails = async (deploymentId) => {
    const deploymentStatus = await this.getDeploymentStatus(deploymentId);
    if (deploymentStatus === DeploymentPipelinesStatus.ERROR) {
      const tasksDescriptions = await this.getDeploymentTasksDescriptions(deploymentId);
      return DeploymentStatus.Error({
        deploymentError: new CliError({
          code: CliErrorCode.DeploymentPipelineFailed({ tasksDescriptions }),
          cause: null
        })
      });
    }
    return DeploymentStatus.Success();
  };
  getDeploymentStatus = async (deploymentId) => {
    try {
      return await pWaitFor(
        async () => {
          const { data } = await pRetry(
            () => this.httpClient.request(getDeployment({ deploymentId })),
            this.retryOptions
          );
          const result = getDeploymentSchema.safeParse(data);
          if (!result.success) {
            throw new CliError({
              code: CliErrorCode.InvalidGetDeploymentResponse(),
              cause: result.error,
              info: { data }
            });
          }
          const { deploymentPipelinesStatus: status } = result.data.deployment;
          if (status === DeploymentPipelinesStatus.IN_PROGRESS) {
            return false;
          }
          return pWaitFor.resolveWith(status);
        },
        {
          // Poll each 2 seconds
          interval: pollInterval ?? 2 * 1e3,
          // Fail if 2 minutes passed
          timeout: 2 * 60 * 1e3
        }
      );
    } catch (error) {
      throw new CliError({
        code: CliErrorCode.FailedToGetDeploymentStatus(),
        cause: error
      });
    }
  };
  getDeploymentTasksDescriptions = async (deploymentId) => {
    try {
      const { data } = await pRetry(
        () => this.httpClient.request(
          getDeploymentPipelineDescription({
            deploymentId,
            deploymentPipelinesIds: [VELO_PIPELINE_ID]
          })
        ),
        this.retryOptions
      );
      const result = getDeploymentPipelineDescriptionSchema.safeParse(data);
      if (!result.success) {
        throw new CliError({
          code: CliErrorCode.InvalidGetDeploymentPipelineDescriptionResponse(),
          cause: result.error,
          info: { data }
        });
      }
      const veloPipeline = result.data.pipelinesDescription.find(
        (item) => item.deploymentPipelineId === VELO_PIPELINE_ID
      );
      return veloPipeline?.tasksDescriptions ?? [];
    } catch (e) {
      throw new CliError({
        code: CliErrorCode.FailedToGetDeploymentPipelineDescription(),
        cause: e
      });
    }
  };
  publishDeployment = async (deploymentId) => {
    try {
      await this.httpClient.request(
        publishDeployment({ deploymentId, skipPipelineCheck: true })
      );
    } catch (error) {
      throw new CliError({
        code: CliErrorCode.FailedToPublishDeployment(),
        cause: error
      });
    }
  };
};

// ../document-management-client/src/useDocumentManagementClient.ts
init_esm_shims();
var import_react = __toESM(require_react(), 1);
function useDocumentManagementClient() {
  const httpClient = useHttpClient({ type: "editor" });
  return (0, import_react.useMemo)(() => new DocumentManagementClient(httpClient), [httpClient]);
}

// ../document-management-client/src/index.ts
init_esm_shims();

// ../cli-site/src/components/PreviewCommand/useCreatePreview.ts
init_esm_shims();
var import_react3 = __toESM(require_react(), 1);

// ../../node_modules/@wix/anyide-document-deployment/dist/src/index.js
init_esm_shims();

// ../../node_modules/@wix/anyide-document-deployment/dist/src/apis/updateSite.js
init_esm_shims();
import { promisify } from "node:util";
import { brotliCompress } from "node:zlib";

// ../../node_modules/@wix/anyide-document-deployment/dist/src/apis/urls.js
init_esm_shims();
var serverlessUrl = () => "https://editor.wix.com/_serverless/dm-anyide-site-deployment";
var getBaseUrl = () => `${serverlessUrl()}/getBase`;
var updateSiteUrl = () => `${serverlessUrl()}/updateSite`;
var getUpdateSiteStatusUrl = (updateSiteTaskId) => `${serverlessUrl()}/getUpdateSiteStatus/${updateSiteTaskId}`;

// ../../node_modules/@wix/anyide-document-deployment/dist/src/apis/updateSite.js
var brotliCompressAsync = promisify(brotliCompress);
var sendUpdateSiteRequest = async (httpClient, request) => {
  const { data } = await httpClient.post(updateSiteUrl(), request);
  return data;
};
var updateSite = async (httpClient, documentUpdate, branchId, revision) => {
  const stringifiedDocumentUpdate = JSON.stringify(documentUpdate);
  const compressedWmlSite = (await brotliCompressAsync(stringifiedDocumentUpdate)).toString("base64");
  const { updateSiteTaskId } = await sendUpdateSiteRequest(httpClient, {
    compressedWmlSite,
    branchId,
    revision
  });
  return updateSiteTaskId;
};

// ../../node_modules/@wix/anyide-document-deployment/dist/src/utils/filterDocumentPagesByHashes.js
init_esm_shims();

// ../../node_modules/@wix/anyide-document-deployment/dist/src/utils/hashWml.js
init_esm_shims();
import crypto from "node:crypto";
var md5 = (str) => crypto.createHash("md5").update(str).digest("hex");
var stringifyWmlFile = ({ content }) => content;
var hashWml = ({ structure, style, data, version }) => {
  const wmlString = version + stringifyWmlFile(structure) + stringifyWmlFile(data) + stringifyWmlFile(style);
  return md5(wmlString);
};

// ../../node_modules/@wix/anyide-document-deployment/dist/src/utils/filterDocumentPagesByHashes.js
var filterDocumentPagesByHashes = (hashes, document) => {
  const filteredDocument = { pages: {} };
  for (const pageId in document.pages) {
    if (hashes[pageId] === void 0) {
      filteredDocument.pages[pageId] = document.pages[pageId];
    }
  }
  for (const pageId in hashes) {
    const documentPage = document.pages[pageId];
    if (documentPage) {
      const pageHash = hashWml(documentPage.data);
      if (pageHash !== hashes[pageId]) {
        filteredDocument.pages[pageId] = documentPage;
      }
    } else {
      filteredDocument.pages[pageId] = null;
    }
  }
  return filteredDocument;
};

// ../../node_modules/@wix/anyide-document-deployment/dist/src/status.js
init_esm_shims();

// ../../node_modules/@wix/anyide-document-deployment/dist/src/apis/getTaskStatus.js
init_esm_shims();
var getTaskStatus = async (httpClient, taskId) => {
  const { data } = await httpClient.get(getUpdateSiteStatusUrl(taskId));
  return data;
};

// ../../node_modules/@wix/anyide-document-deployment/dist/src/status.js
var subscribeToUpdateSiteTaskStatus = (httpClient, updateSiteTaskId, options = {}) => {
  const { onStatusChange, pollInterval: pollInterval3 = 1e3, timeout = 1e3 * 60 * 5 } = options;
  return new Promise((resolve, reject) => {
    const cleanup = () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
    };
    const timeoutId = setTimeout(() => {
      cleanup();
      reject(new Error("deployDocument timeout exceeded"));
    }, timeout);
    const intervalId = setInterval(async () => {
      try {
        const taskStatus = await getTaskStatus(httpClient, updateSiteTaskId);
        onStatusChange?.(taskStatus);
        if (taskStatus.state === "FAILED") {
          cleanup();
          reject(new Error(`Action ${taskStatus.action} failed with error: ${taskStatus.extras?.error}`));
        }
        if (taskStatus.action === "CREATE_REVISION" && taskStatus.state === "DONE") {
          cleanup();
          resolve(taskStatus.extras);
        }
      } catch (error) {
        cleanup();
        reject(error);
      }
    }, pollInterval3);
  });
};

// ../../node_modules/@wix/anyide-document-deployment/dist/src/apis/getBase.js
init_esm_shims();
var getBase = async (httpClient) => {
  const { data } = await httpClient.get(getBaseUrl());
  return data;
};

// ../../node_modules/@wix/anyide-document-deployment/dist/src/index.js
var deployDocument = async (document, options) => {
  const { branchId, revision, hashes } = await getBase(options.httpClient);
  const { httpClient, onStatusChange, pollInterval: pollInterval3, timeout } = options;
  const documentUpdate = filterDocumentPagesByHashes(hashes, document);
  if (Object.keys(documentUpdate.pages).length === 0) {
    return {
      branchId,
      revision
    };
  }
  const updateSiteTaskId = await updateSite(httpClient, documentUpdate, branchId, revision);
  return subscribeToUpdateSiteTaskStatus(httpClient, updateSiteTaskId, { onStatusChange, pollInterval: pollInterval3, timeout });
};

// ../cli-site/src/components/PreviewCommand/useDeploySitePreview.ts
init_esm_shims();
var import_react2 = __toESM(require_react(), 1);
function useDeploySitePreview() {
  const { model } = useProjectModel();
  const { deploySitePreview } = useVeloClient();
  return (0, import_react2.useCallback)(
    async ({ branchId, revision, code }) => {
      const rootFiles = await loadProjectRootFiles(model.projectFolder);
      return deploySitePreview({
        branchId,
        revision: String(revision),
        content: {
          ...code,
          files: code.files.concat(rootFiles),
          layout: GridAppLayout[code.layout]
        }
      });
    },
    [deploySitePreview, model.projectFolder]
  );
}

// ../cli-site/src/components/PreviewCommand/useCreatePreview.ts
var { pollInterval: pollInterval2 } = getTestOverrides();
function toSiteUrl(deploymentUrl) {
  const url = new URL(deploymentUrl);
  url.search = "";
  return url.toString();
}
function useCreatePreview() {
  const dmClient = useDocumentManagementClient();
  const { model } = useProjectModel();
  const httpClient = useHttpClient({ type: "editor" });
  const deploySitePreview = useDeploySitePreview();
  return (0, import_react3.useCallback)(async () => {
    const siteFsManager = await createSiteFsManager(model.projectFolder);
    const [code, document] = await Promise.all([
      siteFsManager.getCode(),
      siteFsManager.getDocument()
    ]);
    const { branchId, revision } = await deployDocument(document, {
      httpClient,
      pollInterval: pollInterval2
    }).catch((error) => {
      throw new CliError({
        code: CliErrorCode.FailedToDeployDocument(),
        cause: error
      });
    });
    const preview = await deploySitePreview({ branchId, revision, code });
    let deploymentStatus = DeploymentStatus.Success();
    if (preview.isPublishPipelineDeployment) {
      deploymentStatus = await dmClient.getDeploymentDetails(
        preview.deploymentId
      );
    }
    return {
      deploymentId: preview.deploymentId,
      previewUrl: preview.deploymentShortUrl ?? preview.deploymentUrl,
      siteUrl: toSiteUrl(preview.deploymentUrl),
      deploymentStatus
    };
  }, [model.projectFolder, httpClient, deploySitePreview, dmClient]);
}

export {
  DeploymentStatus,
  useDocumentManagementClient,
  useCreatePreview
};
//# sourceMappingURL=chunk-YNXR6XGC.js.map