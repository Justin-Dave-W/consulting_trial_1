import { createRequire as _createRequire } from 'node:module';
const require = _createRequire(import.meta.url);
import {
  saveProjectModel
} from "./chunk-KU7XWHFR.js";
import {
  syncTypesWithAuth
} from "./chunk-SELMNFDT.js";
import {
  loadProjectGridAppContent
} from "./chunk-K4EZRW26.js";
import "./chunk-IBISICD2.js";
import {
  createLogger,
  httpRequest
} from "./chunk-RNE7RRCK.js";
import {
  createI18nT
} from "./chunk-2G7FRAIA.js";
import "./chunk-CNXKF7E3.js";
import {
  authenticate
} from "./chunk-PAPTRQZR.js";
import {
  createVeloCLIServer,
  debounceQueue,
  require_chokidar
} from "./chunk-XVW7HYN2.js";
import {
  require_normalize_path
} from "./chunk-EDFOB3LN.js";
import "./chunk-7EAHB7TU.js";
import {
  execa
} from "./chunk-E2POOOG2.js";
import "./chunk-OJHDGJWP.js";
import {
  updateFiles
} from "./chunk-SNWTG76C.js";
import {
  GridAppLayout
} from "./chunk-6LI4WGAW.js";
import {
  AppType,
  GridAppLayout as GridAppLayout2,
  createApp,
  pagesDiff
} from "./chunk-DDC4C6V6.js";
import "./chunk-KWG4MUE3.js";
import {
  createHttpClient,
  isHttpError,
  openBrowser,
  pLimit,
  pRetry,
  resolveUrl,
  serializer,
  toURLSearchParams
} from "./chunk-O25O35J2.js";
import {
  ErrorViewer,
  extractHttpError,
  writeCrashReport
} from "./chunk-7VND5WMC.js";
import {
  wixCliCliMessageDisplayed,
  wixCliCodeHasBeenChanged,
  wixCliFileFolderCreatedRenamedDeleted,
  wixCliReadyForReloadAfterCodeChange,
  wixCliUserResponseToCliMessage
} from "./chunk-WN3D6AOY.js";
import {
  renderSync,
  require_react
} from "./chunk-OH3G6JMX.js";
import "./chunk-W423UTD3.js";
import "./chunk-2K5KKUL3.js";
import "./chunk-YU54OBFT.js";
import "./chunk-XMTHMR2B.js";
import "./chunk-VSMZTFUW.js";
import {
  getDebugLogFilePath,
  getPagesFolder,
  getSourceFolder,
  getTypesDir
} from "./chunk-2CPXK3HU.js";
import {
  outputFile,
  pathExists
} from "./chunk-F6DVF5WQ.js";
import {
  getTestOverrides,
  z
} from "./chunk-GNB7T7J7.js";
import {
  CliError,
  CliErrorCode
} from "./chunk-CVJG3VZM.js";
import {
  __commonJS,
  __dirname,
  __require,
  __toESM,
  init_esm_shims
} from "./chunk-PYIAC2GK.js";

// ../../node_modules/cloudflared/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/cloudflared/lib/constants.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var constants_exports = {};
    __export(constants_exports, {
      CLOUDFLARED_VERSION: () => CLOUDFLARED_VERSION,
      DEFAULT_CLOUDFLARED_BIN: () => DEFAULT_CLOUDFLARED_BIN,
      RELEASE_BASE: () => RELEASE_BASE,
      bin: () => bin3,
      use: () => use
    });
    module.exports = __toCommonJS(constants_exports);
    var import_node_path4 = __toESM2(__require("node:path"));
    var DEFAULT_CLOUDFLARED_BIN = import_node_path4.default.join(__dirname, "..", "bin", process.platform === "win32" ? "cloudflared.exe" : "cloudflared");
    var bin3 = process.env.CLOUDFLARED_BIN || DEFAULT_CLOUDFLARED_BIN;
    function use(executable) {
      bin3 = executable;
    }
    var CLOUDFLARED_VERSION = process.env.CLOUDFLARED_VERSION || "latest";
    var RELEASE_BASE = "https://github.com/cloudflare/cloudflared/releases/";
  }
});

// ../../node_modules/cloudflared/lib/error.js
var require_error = __commonJS({
  "../../node_modules/cloudflared/lib/error.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var error_exports = {};
    __export(error_exports, {
      UnsupportedError: () => UnsupportedError
    });
    module.exports = __toCommonJS(error_exports);
    var UnsupportedError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
  }
});

// ../../node_modules/cloudflared/lib/install.js
var require_install = __commonJS({
  "../../node_modules/cloudflared/lib/install.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var install_exports = {};
    __export(install_exports, {
      install: () => install3,
      install_linux: () => install_linux,
      install_macos: () => install_macos,
      install_windows: () => install_windows
    });
    module.exports = __toCommonJS(install_exports);
    var import_node_fs = __toESM2(__require("node:fs"));
    var import_node_path4 = __toESM2(__require("node:path"));
    var import_node_https = __toESM2(__require("node:https"));
    var import_node_child_process = __require("node:child_process");
    var import_constants = require_constants();
    var import_error = require_error();
    var LINUX_URL = {
      arm64: "cloudflared-linux-arm64",
      arm: "cloudflared-linux-arm",
      x64: "cloudflared-linux-amd64",
      ia32: "cloudflared-linux-386"
    };
    var MACOS_URL = {
      arm64: "cloudflared-darwin-amd64.tgz",
      x64: "cloudflared-darwin-amd64.tgz"
    };
    var WINDOWS_URL = {
      x64: "cloudflared-windows-amd64.exe",
      ia32: "cloudflared-windows-386.exe"
    };
    function resolve_base(version) {
      if (version === "latest") {
        return `${import_constants.RELEASE_BASE}latest/download/`;
      }
      return `${import_constants.RELEASE_BASE}download/${version}/`;
    }
    async function install3(to, version = import_constants.CLOUDFLARED_VERSION) {
      if (process.platform === "linux") {
        return install_linux(to, version);
      } else if (process.platform === "darwin") {
        return install_macos(to, version);
      } else if (process.platform === "win32") {
        return install_windows(to, version);
      } else {
        throw new import_error.UnsupportedError("Unsupported platform: " + process.platform);
      }
    }
    async function install_linux(to, version = import_constants.CLOUDFLARED_VERSION) {
      const file = LINUX_URL[process.arch];
      if (file === void 0) {
        throw new import_error.UnsupportedError("Unsupported architecture: " + process.arch);
      }
      await download(resolve_base(version) + file, to);
      import_node_fs.default.chmodSync(to, "755");
      return to;
    }
    async function install_macos(to, version = import_constants.CLOUDFLARED_VERSION) {
      const file = MACOS_URL[process.arch];
      if (file === void 0) {
        throw new import_error.UnsupportedError("Unsupported architecture: " + process.arch);
      }
      await download(resolve_base(version) + file, `${to}.tgz`);
      process.env.VERBOSE && console.log(`Extracting to ${to}`);
      (0, import_node_child_process.execSync)(`tar -xzf ${import_node_path4.default.basename(`${to}.tgz`)}`, { cwd: import_node_path4.default.dirname(to) });
      import_node_fs.default.unlinkSync(`${to}.tgz`);
      import_node_fs.default.renameSync(`${import_node_path4.default.dirname(to)}/cloudflared`, to);
      return to;
    }
    async function install_windows(to, version = import_constants.CLOUDFLARED_VERSION) {
      const file = WINDOWS_URL[process.arch];
      if (file === void 0) {
        throw new import_error.UnsupportedError("Unsupported architecture: " + process.arch);
      }
      await download(resolve_base(version) + file, to);
      return to;
    }
    function download(url, to, redirect = 0) {
      if (redirect === 0) {
        process.env.VERBOSE && console.log(`Downloading ${url} to ${to}`);
      } else {
        process.env.VERBOSE && console.log(`Redirecting to ${url}`);
      }
      if (!import_node_fs.default.existsSync(import_node_path4.default.dirname(to))) {
        import_node_fs.default.mkdirSync(import_node_path4.default.dirname(to), { recursive: true });
      }
      return new Promise((resolve, reject) => {
        const request = import_node_https.default.get(url, (res) => {
          const redirect_code = [301, 302, 303, 307, 308];
          if (redirect_code.includes(res.statusCode) && res.headers.location !== void 0) {
            request.destroy();
            const redirection = res.headers.location;
            resolve(download(redirection, to, redirect + 1));
            return;
          }
          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
            const file = import_node_fs.default.createWriteStream(to);
            file.on("finish", () => {
              file.close(() => resolve(to));
            });
            file.on("error", (err) => {
              import_node_fs.default.unlink(to, () => reject(err));
            });
            res.pipe(file);
          } else {
            request.destroy();
            reject(new Error(`HTTP response with status code: ${res.statusCode}`));
          }
        });
        request.on("error", (err) => {
          reject(err);
        });
        request.end();
      });
    }
  }
});

// ../../node_modules/cloudflared/lib/regex.js
var require_regex = __commonJS({
  "../../node_modules/cloudflared/lib/regex.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var regex_exports = {};
    __export(regex_exports, {
      config_regex: () => config_regex,
      conn_regex: () => conn_regex,
      connectorID_regex: () => connectorID_regex,
      disconnect_regex: () => disconnect_regex,
      index_regex: () => index_regex,
      ip_regex: () => ip_regex,
      location_regex: () => location_regex,
      metrics_regex: () => metrics_regex,
      tunnelID_regex: () => tunnelID_regex
    });
    module.exports = __toCommonJS(regex_exports);
    var conn_regex = /connection[= ]([0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12})/i;
    var ip_regex = /ip=([0-9.]+)/;
    var location_regex = /location=([A-Za-z0-9]+)/;
    var index_regex = /connIndex=(\d)/;
    var disconnect_regex = /Unregistered tunnel connection connIndex=(\d)/i;
    var tunnelID_regex = /tunnelID=([0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12})/i;
    var connectorID_regex = /Connector ID: ([0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12})/i;
    var metrics_regex = /metrics server on ([0-9.:]+\/metrics)/;
    var config_regex = /config="(.+[^\\])"/;
  }
});

// ../../node_modules/cloudflared/lib/tunnel.js
var require_tunnel = __commonJS({
  "../../node_modules/cloudflared/lib/tunnel.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var tunnel_exports = {};
    __export(tunnel_exports, {
      tunnel: () => tunnel2
    });
    module.exports = __toCommonJS(tunnel_exports);
    var import_node_child_process = __require("node:child_process");
    var import_constants = require_constants();
    var import_regex = require_regex();
    function tunnel2(options = {}) {
      const args = ["tunnel"];
      for (const [key, value] of Object.entries(options)) {
        if (typeof value === "string") {
          args.push(`${key}`, value);
        } else if (typeof value === "number") {
          args.push(`${key}`, value.toString());
        } else if (value === null) {
          args.push(`${key}`);
        }
      }
      if (args.length === 1) {
        args.push("--url", "localhost:8080");
      }
      const child = (0, import_node_child_process.spawn)(import_constants.bin, args, { stdio: ["ignore", "pipe", "pipe"] });
      if (process.env.VERBOSE) {
        child.stdout.pipe(process.stdout);
        child.stderr.pipe(process.stderr);
      }
      const url_regex = /\|\s+(https?:\/\/[^\s]+)/;
      let url_resolver = () => void 0;
      let url_rejector = () => void 0;
      const url = new Promise((...pair) => [url_resolver, url_rejector] = pair);
      const connection_resolvers = [];
      const connection_rejectors = [];
      const connections = [];
      for (let i = 0; i < 1; i++) {
        connections.push(new Promise((...pair) => [connection_resolvers[i], connection_rejectors[i]] = pair));
      }
      const parser = (data) => {
        var _a;
        const str = data.toString();
        const url_match = str.match(url_regex);
        url_match && url_resolver(url_match[1]);
        const conn_match = str.match(import_regex.conn_regex);
        const ip_match = str.match(import_regex.ip_regex);
        const location_match = str.match(import_regex.location_regex);
        const index_match = str.match(import_regex.index_regex);
        if (conn_match && ip_match && location_match && index_match) {
          const [, id] = conn_match;
          const [, ip] = ip_match;
          const [, location] = location_match;
          const [, idx] = index_match;
          (_a = connection_resolvers[+idx]) == null ? void 0 : _a.call(connection_resolvers, { id, ip, location });
        }
      };
      child.stdout.on("data", parser).on("error", url_rejector);
      child.stderr.on("data", parser).on("error", url_rejector);
      const stop = () => child.kill("SIGINT");
      return { url, connections, child, stop };
    }
  }
});

// ../../node_modules/cloudflared/lib/service.js
var require_service = __commonJS({
  "../../node_modules/cloudflared/lib/service.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var service_exports = {};
    __export(service_exports, {
      AlreadyInstalledError: () => AlreadyInstalledError2,
      LINUX_SERVICE_PATH: () => LINUX_SERVICE_PATH,
      MACOS_SERVICE_PATH: () => MACOS_SERVICE_PATH2,
      NotInstalledError: () => NotInstalledError2,
      clean: () => clean,
      current: () => current,
      err: () => err,
      exists: () => exists,
      identifier: () => identifier2,
      install: () => install3,
      journal: () => journal,
      log: () => log,
      service: () => service2,
      service_name: () => service_name,
      uninstall: () => uninstall
    });
    module.exports = __toCommonJS(service_exports);
    var import_node_os = __toESM2(__require("node:os"));
    var import_node_fs = __toESM2(__require("node:fs"));
    var import_node_child_process = __require("node:child_process");
    var import_constants = require_constants();
    var import_regex = require_regex();
    var identifier2 = "com.cloudflare.cloudflared";
    var service_name = "cloudflared.service";
    var MACOS_SERVICE_PATH2 = {
      PLIST: is_root() ? `/Library/LaunchDaemons/${identifier2}.plist` : `${import_node_os.default.homedir()}/Library/LaunchAgents/${identifier2}.plist`,
      OUT: is_root() ? `/Library/Logs/${identifier2}.out.log` : `${import_node_os.default.homedir()}/Library/Logs/${identifier2}.out.log`,
      ERR: is_root() ? `/Library/Logs/${identifier2}.err.log` : `${import_node_os.default.homedir()}/Library/Logs/${identifier2}.err.log`
    };
    var LINUX_SERVICE_PATH = {
      SYSTEMD: `/etc/systemd/system/${service_name}`,
      SERVICE: "/etc/init.d/cloudflared",
      SERVICE_OUT: "/var/log/cloudflared.log",
      SERVICE_ERR: "/var/log/cloudflared.err"
    };
    var service2 = { install: install3, uninstall, exists, log, err, current, clean, journal };
    var AlreadyInstalledError2 = class extends Error {
      constructor() {
        super("service is already installed");
      }
    };
    var NotInstalledError2 = class extends Error {
      constructor() {
        super("service is not installed");
      }
    };
    function install3(token) {
      if (!["darwin", "linux"].includes(process.platform)) {
        throw new Error(`Not Implemented on platform ${process.platform}`);
      }
      if (exists()) {
        throw new AlreadyInstalledError2();
      }
      const args = ["service", "install"];
      if (token) {
        args.push(token);
      }
      const result = (0, import_node_child_process.spawnSync)(import_constants.bin, args);
      if (result.status !== 0) {
        throw new Error(`service install failed: ${result.stderr.toString()}`);
      }
    }
    function uninstall() {
      if (!["darwin", "linux"].includes(process.platform)) {
        throw new Error(`Not Implemented on platform ${process.platform}`);
      }
      if (!exists()) {
        throw new NotInstalledError2();
      }
      const result = (0, import_node_child_process.spawnSync)(import_constants.bin, ["service", "uninstall"]);
      if (result.status !== 0) {
        throw new Error(`service uninstall failed: ${result.stderr.toString()}`);
      }
      if (process.platform === "darwin") {
        import_node_fs.default.rmSync(MACOS_SERVICE_PATH2.OUT);
        import_node_fs.default.rmSync(MACOS_SERVICE_PATH2.ERR);
      } else if (process.platform === "linux" && !is_systemd()) {
        import_node_fs.default.rmSync(LINUX_SERVICE_PATH.SERVICE_OUT);
        import_node_fs.default.rmSync(LINUX_SERVICE_PATH.SERVICE_ERR);
      }
    }
    function log() {
      if (!exists()) {
        throw new NotInstalledError2();
      }
      if (process.platform === "darwin") {
        return import_node_fs.default.readFileSync(MACOS_SERVICE_PATH2.OUT, "utf8");
      }
      if (process.platform === "linux" && !is_systemd()) {
        return import_node_fs.default.readFileSync(LINUX_SERVICE_PATH.SERVICE_OUT, "utf8");
      }
      throw new Error(`Not Implemented on platform ${process.platform}`);
    }
    function err() {
      if (!exists()) {
        throw new NotInstalledError2();
      }
      if (process.platform === "darwin") {
        return import_node_fs.default.readFileSync(MACOS_SERVICE_PATH2.ERR, "utf8");
      }
      if (process.platform === "linux" && !is_systemd()) {
        return import_node_fs.default.readFileSync(LINUX_SERVICE_PATH.SERVICE_ERR, "utf8");
      }
      throw new Error(`Not Implemented on platform ${process.platform}`);
    }
    function journal(n = 300) {
      if (process.platform === "linux" && is_systemd()) {
        const args = ["-u", service_name, "-o", "cat", "-n", n.toString()];
        return (0, import_node_child_process.spawnSync)("journalctl", args).stdout.toString();
      }
      throw new Error(`Not Implemented on platform ${process.platform}`);
    }
    function current() {
      var _a, _b, _c, _d;
      if (!["darwin", "linux"].includes(process.platform)) {
        throw new Error(`Not Implemented on platform ${process.platform}`);
      }
      if (!exists()) {
        throw new NotInstalledError2();
      }
      const log2 = is_systemd() ? journal() : err();
      let tunnelID = "";
      let connectorID = "";
      const connections = [];
      let metrics = "";
      let config = {};
      for (const line of log2.split("\n")) {
        try {
          if (line.match(import_regex.tunnelID_regex)) {
            tunnelID = ((_a = line.match(import_regex.tunnelID_regex)) == null ? void 0 : _a[1]) ?? "";
          } else if (line.match(import_regex.connectorID_regex)) {
            connectorID = ((_b = line.match(import_regex.connectorID_regex)) == null ? void 0 : _b[1]) ?? "";
          } else if (line.match(import_regex.conn_regex) && line.match(import_regex.location_regex) && line.match(import_regex.ip_regex) && line.match(import_regex.index_regex)) {
            const [, id] = line.match(import_regex.conn_regex) ?? [];
            const [, location] = line.match(import_regex.location_regex) ?? [];
            const [, ip] = line.match(import_regex.ip_regex) ?? [];
            const [, idx] = line.match(import_regex.index_regex) ?? [];
            connections[parseInt(idx)] = { id, ip, location };
          } else if (line.match(import_regex.disconnect_regex)) {
            const [, idx] = line.match(import_regex.disconnect_regex) ?? [];
            if (parseInt(idx) in connections) {
              connections[parseInt(idx)] = { id: "", ip: "", location: "" };
            }
          } else if (line.match(import_regex.metrics_regex)) {
            metrics = ((_c = line.match(import_regex.metrics_regex)) == null ? void 0 : _c[1]) ?? "";
          } else if (line.match(import_regex.config_regex)) {
            config = JSON.parse(((_d = line.match(import_regex.config_regex)) == null ? void 0 : _d[1].replace(/\\/g, "")) ?? "{}");
          }
        } catch (err2) {
          if (process.env.VERBOSE) {
            console.error("log parsing failed", err2);
          }
        }
      }
      return { tunnelID, connectorID, connections, metrics, config };
    }
    function clean() {
      if (process.platform !== "darwin") {
        throw new Error(`Not Implemented on platform ${process.platform}`);
      }
      if (exists()) {
        throw new AlreadyInstalledError2();
      }
      import_node_fs.default.rmSync(MACOS_SERVICE_PATH2.OUT, { force: true });
      import_node_fs.default.rmSync(MACOS_SERVICE_PATH2.ERR, { force: true });
    }
    function exists() {
      if (process.platform === "darwin") {
        return import_node_fs.default.existsSync(MACOS_SERVICE_PATH2.PLIST);
      } else if (process.platform === "linux") {
        return is_systemd() ? import_node_fs.default.existsSync(LINUX_SERVICE_PATH.SYSTEMD) : import_node_fs.default.existsSync(LINUX_SERVICE_PATH.SERVICE);
      }
      throw new Error(`Not Implemented on platform ${process.platform}`);
    }
    function is_root() {
      var _a;
      return ((_a = process.getuid) == null ? void 0 : _a.call(process)) === 0;
    }
    function is_systemd() {
      return process.platform === "linux" && import_node_fs.default.existsSync("/run/systemd/system");
    }
  }
});

// ../../node_modules/cloudflared/lib/lib.js
var require_lib = __commonJS({
  "../../node_modules/cloudflared/lib/lib.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var lib_exports = {};
    __export(lib_exports, {
      AlreadyInstalledError: () => import_service.AlreadyInstalledError,
      MACOS_SERVICE_PATH: () => import_service.MACOS_SERVICE_PATH,
      NotInstalledError: () => import_service.NotInstalledError,
      bin: () => import_constants.bin,
      identifier: () => import_service.identifier,
      install: () => import_install.install,
      service: () => import_service.service,
      tunnel: () => import_tunnel2.tunnel
    });
    module.exports = __toCommonJS(lib_exports);
    var import_constants = require_constants();
    var import_install = require_install();
    var import_tunnel2 = require_tunnel();
    var import_service = require_service();
  }
});

// ../cli-site-old/src/dev/index.ts
init_esm_shims();

// ../cli-site-old/src/dev/dev.ts
init_esm_shims();

// ../../node_modules/exit-hook/index.js
init_esm_shims();
import process2 from "node:process";
var asyncCallbacks = /* @__PURE__ */ new Set();
var callbacks = /* @__PURE__ */ new Set();
var isCalled = false;
var isRegistered = false;
async function exit(shouldManuallyExit, isSynchronous, signal) {
  if (isCalled) {
    return;
  }
  isCalled = true;
  if (asyncCallbacks.size > 0 && isSynchronous) {
    console.error([
      "SYNCHRONOUS TERMINATION NOTICE:",
      "When explicitly exiting the process via process.exit or via a parent process,",
      "asynchronous tasks in your exitHooks will not run. Either remove these tasks,",
      "use gracefulExit() instead of process.exit(), or ensure your parent process",
      "sends a SIGINT to the process running this code."
    ].join(" "));
  }
  const exitCode = 128 + signal;
  const done = (force = false) => {
    if (force === true || shouldManuallyExit === true) {
      process2.exit(exitCode);
    }
  };
  for (const callback of callbacks) {
    callback(exitCode);
  }
  if (isSynchronous) {
    done();
    return;
  }
  const promises = [];
  let forceAfter = 0;
  for (const [callback, wait] of asyncCallbacks) {
    forceAfter = Math.max(forceAfter, wait);
    promises.push(Promise.resolve(callback(exitCode)));
  }
  const asyncTimer = setTimeout(() => {
    done(true);
  }, forceAfter);
  await Promise.all(promises);
  clearTimeout(asyncTimer);
  done();
}
function addHook(options) {
  const { onExit, wait, isSynchronous } = options;
  const asyncCallbackConfig = [onExit, wait];
  if (isSynchronous) {
    callbacks.add(onExit);
  } else {
    asyncCallbacks.add(asyncCallbackConfig);
  }
  if (!isRegistered) {
    isRegistered = true;
    process2.once("beforeExit", exit.bind(void 0, true, false, -128));
    process2.once("SIGINT", exit.bind(void 0, true, false, 2));
    process2.once("SIGTERM", exit.bind(void 0, true, false, 15));
    process2.once("exit", exit.bind(void 0, false, true, 0));
    process2.on("message", (message) => {
      if (message === "shutdown") {
        exit(true, true, -128);
      }
    });
  }
  return () => {
    if (isSynchronous) {
      callbacks.delete(onExit);
    } else {
      asyncCallbacks.delete(asyncCallbackConfig);
    }
  };
}
function asyncExitHook(onExit, options = {}) {
  if (typeof onExit !== "function") {
    throw new TypeError("onExit must be a function");
  }
  if (!(typeof options.wait === "number" && options.wait > 0)) {
    throw new TypeError("wait must be set to a positive numeric value");
  }
  return addHook({
    onExit,
    wait: options.wait,
    isSynchronous: false
  });
}

// ../cli-site-old/src/dev/dev.ts
var import_react = __toESM(require_react(), 1);

// ../cli-tunnel/src/index.ts
init_esm_shims();

// ../cli-tunnel/src/tunnel.ts
init_esm_shims();
import { dirname } from "node:path";
var import_cloudflared = __toESM(require_lib(), 1);
async function launchTunnel(port, tunnelClient) {
  const { localTunnel } = getTestOverrides();
  if (!localTunnel && !await pathExists(import_cloudflared.bin)) {
    try {
      await (0, import_cloudflared.install)(import_cloudflared.bin);
    } catch (e) {
      const err = e;
      if (e instanceof Error && err.code === "EACCES") {
        throw new CliError({
          code: CliErrorCode.FailedInstallCloudflareNoAccess({
            path: dirname(err.path)
          }),
          cause: e
        });
      }
      throw e;
    }
  }
  const tunnel2 = await tunnelClient.createTunnel({ port });
  const domain = `http${localTunnel ? "" : "s"}://${tunnel2.domain}`;
  const createTunnelPromise = new Promise((resolve, reject) => {
    const tunnelProcess = localTunnel ? execa("echo", [tunnel2.domain, tunnel2.token], { detached: true }) : execa(import_cloudflared.bin, ["tunnel", "run", "--token", tunnel2.token]);
    const close = () => {
      tunnelProcess.kill();
    };
    const listener = async (data) => {
      const output = data.toString();
      const match = output.match(tunnel2.domain)?.[0];
      if (match) {
        resolve({
          domain,
          close
        });
      }
    };
    tunnelProcess.stderr?.on("data", listener);
    tunnelProcess.stdout?.on("data", listener);
    tunnelProcess.on("error", (err) => {
      reject(err);
    });
  });
  return {
    domain,
    close: async () => {
      const tunnel3 = await createTunnelPromise;
      return tunnel3.close();
    }
  };
}

// ../cli-tunnel/src/client.ts
init_esm_shims();

// ../../node_modules/@wix/ambassador-apps-hosting-v1-deployment/build/es/http.impl.js
init_esm_shims();
var _createTunnelRequest = {};
var _createTunnelResponse = {};
var _deleteTunnelRequest = {};
var _deleteTunnelResponse = {};
function resolveWixAppsHostingV1BackendServiceUrl(opts) {
  var domainToMappings = {
    "bo._base_domain_": [
      {
        srcPath: "/_serverless/wix-app-backend-manager",
        destPath: ""
      }
    ],
    "wixbo.ai": [
      {
        srcPath: "/_serverless/wix-app-backend-manager",
        destPath: ""
      }
    ],
    "wix-bo.com": [
      {
        srcPath: "/_serverless/wix-app-backend-manager",
        destPath: ""
      }
    ],
    "manage._base_domain_": [
      {
        srcPath: "/_serverless/wix-app-backend-manager",
        destPath: ""
      }
    ]
  };
  return resolveUrl(Object.assign(opts, { domainToMappings }));
}
function createTunnel(payload) {
  var _a = serializer(_createTunnelRequest, {}), toReq = _a.toJSON, fromReq = _a.fromJSON;
  var fromRes = serializer(_createTunnelResponse, {}).fromJSON;
  function __createTunnel(_a2) {
    var host = _a2.host;
    var serializedData = toReq(payload);
    var metadata = {
      entityFqdn: "wix.apps.hosting.v1.deployment",
      method: "POST",
      methodFqn: "wix.apps.hosting.v1.BackendService.CreateTunnel",
      url: resolveWixAppsHostingV1BackendServiceUrl({
        protoPath: "/v1/tunnel",
        data: serializedData,
        host
      }),
      data: serializedData,
      transformResponse: fromRes
    };
    return metadata;
  }
  __createTunnel.fromReq = fromReq;
  __createTunnel.__isAmbassador = true;
  return __createTunnel;
}
function deleteTunnel(payload) {
  var _a = serializer(_deleteTunnelRequest, {}), toReq = _a.toJSON, fromReq = _a.fromJSON;
  var fromRes = serializer(_deleteTunnelResponse, {}).fromJSON;
  function __deleteTunnel(_a2) {
    var host = _a2.host;
    var serializedData = toReq(payload);
    var metadata = {
      entityFqdn: "wix.apps.hosting.v1.deployment",
      method: "DELETE",
      methodFqn: "wix.apps.hosting.v1.BackendService.DeleteTunnel",
      url: resolveWixAppsHostingV1BackendServiceUrl({
        protoPath: "/v1/tunnel",
        data: serializedData,
        host
      }),
      params: toURLSearchParams(serializedData),
      transformResponse: fromRes
    };
    return metadata;
  }
  __deleteTunnel.fromReq = fromReq;
  __deleteTunnel.__isAmbassador = true;
  return __deleteTunnel;
}

// ../cli-tunnel/src/schemas.ts
init_esm_shims();
var createTunnelSchema = z.object({
  id: z.string(),
  token: z.string(),
  domain: z.string()
});

// ../cli-tunnel/src/client.ts
var TunnelClient = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
    const { minRetryTimeout } = getTestOverrides();
    this.retryOptions = {
      retries: 3,
      minTimeout: minRetryTimeout,
      maxTimeout: 3 * 1e3
    };
  }
  retryOptions;
  createTunnel = async ({ port }) => {
    try {
      const { data } = await pRetry(
        () => this.httpClient.request(createTunnel({ port })),
        this.retryOptions
      );
      return createTunnelSchema.parse(data);
    } catch (error) {
      throw new CliError({
        code: CliErrorCode.FailedToCreateTunnel(),
        cause: error
      });
    }
  };
  deleteTunnel = async (tunnelId) => {
    try {
      await pRetry(
        () => this.httpClient.request(deleteTunnel({ id: tunnelId })),
        this.retryOptions
      );
    } catch (error) {
      throw new CliError({
        code: CliErrorCode.FailedToDeleteTunnel(),
        cause: error
      });
    }
  };
};

// ../cli-site-old/src/environment.ts
init_esm_shims();
var DEV_EDITOR_BASE_URL = "https://wix.com/editor/";
function getDevEditorBaseUrl() {
  return getTestOverrides().devEditorBaseUrl ?? DEV_EDITOR_BASE_URL;
}

// ../cli-site-old/src/gridapp/createGridApp.ts
init_esm_shims();

// ../cli-site-old/src/gridapp/error-handlers/maxFileSizeErrorHandler.ts
init_esm_shims();
function catchFilesMaxSizeError(err, files = []) {
  if (!files.length) {
    return;
  }
  const httpError = extractHttpError(err);
  if (!httpError) {
    return;
  }
  const filesMaxSizeRawViolations = httpError.response?.data?.details?.validationError?.fieldViolations?.filter(
    (v) => v.violatedRule === "MAX_LENGTH"
  );
  if (!filesMaxSizeRawViolations?.length) {
    return;
  }
  const maxSizeViolationsData = tryExtractMaxSizeViolationMetadata(
    filesMaxSizeRawViolations
  );
  throw new CliError({
    code: CliErrorCode.GridAppFilesMaxLengthExceeded({
      maxSizeViolationsData,
      filePaths: files.map((f) => f.path ?? "[unknown file path]")
    }),
    cause: httpError
  });
}
function tryExtractMaxSizeViolationMetadata(filesMaxSizeViolations) {
  const fileIndexRegex = /\[(?<fileIndex>\d+)\].content/;
  const expectedAndReceivedSizeRegex = /has size (?<receivedSize>\d+), expected (?<expectedSize>\d+) or less/;
  const violationsData = {
    expectedSize: void 0,
    files: []
  };
  for (const filesMaxSizeViolation of filesMaxSizeViolations) {
    const fileIndexMatchResult = fileIndexRegex.exec(
      filesMaxSizeViolation.field
    );
    const expectedAndReceivedSizeMatchResult = expectedAndReceivedSizeRegex.exec(filesMaxSizeViolation.description);
    if (!(fileIndexMatchResult?.groups?.fileIndex && expectedAndReceivedSizeMatchResult?.groups?.receivedSize && expectedAndReceivedSizeMatchResult.groups.expectedSize)) {
      return null;
    }
    violationsData.expectedSize ??= Math.trunc(
      parseInt(expectedAndReceivedSizeMatchResult.groups.expectedSize, 10) / 1e3
    );
    violationsData.files.push({
      receivedSize: Math.trunc(
        parseInt(expectedAndReceivedSizeMatchResult.groups.receivedSize, 10) / 1e3
      ),
      fileIndex: parseInt(fileIndexMatchResult.groups.fileIndex, 10)
    });
  }
  return violationsData;
}

// ../cli-site-old/src/gridapp/createGridApp.ts
async function createAppWithParams(params, opts) {
  let app;
  try {
    const response = await httpRequest(
      { type: "code", authState: opts.authState },
      createApp(params)
    );
    app = response.data.app;
  } catch (err) {
    catchFilesMaxSizeError(err, params.content?.files);
    throw err;
  }
  if (!app?.id) {
    throw new CliError({
      code: CliErrorCode.InvalidCreateAppResponse(),
      info: { app },
      cause: null
    });
  }
  return app.id;
}
async function createMutableGridApp(projectFolder, opts) {
  const content = await loadProjectGridAppContent(projectFolder);
  return createAppWithParams(
    {
      app: {
        mutable: true,
        appType: AppType.VELO_ISOLATED
      },
      content
    },
    opts
  );
}

// ../cli-site-old/src/gridapp/startGridAppUpdater.ts
init_esm_shims();
import { readFile } from "node:fs/promises";
import { join } from "node:path";
var import_chokidar = __toESM(require_chokidar(), 1);
var import_normalize_path = __toESM(require_normalize_path(), 1);
var WATCH_FS_EVENTS_DEBOUNCE_TIME = 1e3;
var getSectionName = (path) => {
  if (path.startsWith("src/pages")) {
    return "public";
  }
  if (path.startsWith("src/backend")) {
    return "backend";
  }
  return "other";
};
function startGridAppUpdater(model, gridAppId, opts, logger, biEvents) {
  const { projectFolder } = model;
  const limit = pLimit(1);
  const watcher = (0, import_chokidar.watch)(getSourceFolder(projectFolder), {
    disableGlobbing: true,
    cwd: projectFolder,
    ignoreInitial: true
  }).on(
    "all",
    debounceQueue(async (events) => {
      await limit(async () => {
        const logSynced = logger.logSyncingLocalCode();
        const { added, changed, removed } = normalizeChokidarBatchedEvents(events);
        const addedArray = Array.from(added.values()).map((path) => ({
          path,
          type: "create"
        }));
        const changedArray = Array.from(changed.values()).map((path) => ({
          path,
          type: "update"
        }));
        const removedArray = Array.from(removed.values()).map((path) => ({
          path,
          type: "delete"
        }));
        for (const val of [...addedArray, ...changedArray, ...removedArray]) {
          biEvents.file({
            model,
            action: val.type,
            path: val.path,
            oldPath: "",
            sectionName: getSectionName(val.path)
          });
          if (val.type === "update") {
            biEvents.codeChanged(model, val.path);
          }
        }
        try {
          await writeFiles({
            filesToUpdate: await Promise.all(
              addedArray.concat(changedArray).map(async (val) => ({
                path: (0, import_normalize_path.default)(val.path),
                content: await readFile(
                  join(projectFolder, val.path),
                  "utf8"
                )
              }))
            ),
            removedArray,
            gridAppId,
            authState: opts.authState
          });
          const message = logSynced.success();
          biEvents.messageDisplayed({ message, model });
          biEvents.readyForReloadAfterCodeChanged(model);
        } catch (e) {
          logSynced.fail();
          const error = new CliError({
            code: CliErrorCode.GridAppFailedToUpdateFiles(),
            cause: e,
            info: {
              added,
              changed,
              removed
            }
          });
          opts.onError(error);
        }
      });
    }, WATCH_FS_EVENTS_DEBOUNCE_TIME)
  ).on("error", (e) => {
    const error = new CliError({
      code: CliErrorCode.FailedToWatchFiles(),
      cause: e
    });
    opts.onError(error);
  });
  return { close: () => watcher.close() };
}
function normalizeChokidarBatchedEvents(events) {
  return events.reduce(
    (result, [eventType, filePath]) => {
      switch (eventType) {
        case "add": {
          result.added.add(filePath);
          break;
        }
        case "change": {
          result.changed.add(filePath);
          break;
        }
        case "unlink": {
          result.added.delete(filePath);
          result.changed.delete(filePath);
          result.removed.add(filePath);
          break;
        }
        case "unlinkDir": {
          const filePathAsDir = filePath.endsWith("/") ? filePath : `${filePath}/`;
          for (const filePath2 of result.added) {
            if (filePath2.startsWith(filePathAsDir)) {
              result.added.delete(filePath2);
            }
          }
          for (const filePath2 of result.changed) {
            if (filePath2.startsWith(filePathAsDir)) {
              result.changed.delete(filePath2);
            }
          }
          result.removed.add(filePath);
          break;
        }
        case "addDir": {
          break;
        }
      }
      return result;
    },
    {
      added: /* @__PURE__ */ new Set(),
      changed: /* @__PURE__ */ new Set(),
      removed: /* @__PURE__ */ new Set()
    }
  );
}
async function writeFiles({
  filesToUpdate,
  removedArray,
  gridAppId,
  authState
}) {
  try {
    await httpRequest(
      {
        type: "code",
        authState
      },
      updateFiles({
        gridAppId,
        layout: GridAppLayout.GITHUB,
        filesToUpdate,
        ignoreForbiddenPaths: true,
        pathsToDelete: removedArray.map((val) => val.path)
      })
    );
  } catch (err) {
    catchFilesMaxSizeError(err, filesToUpdate);
    throw err;
  }
}

// ../cli-site-old/src/key-watcher.ts
init_esm_shims();
import readline from "node:readline";
import { stdin } from "node:process";
var KeyWatcher = class {
  actions = /* @__PURE__ */ new Map();
  watchExitProcess() {
    return new Promise((resolve) => {
      this.on("c", (key) => {
        if (key.ctrl) {
          resolve();
        }
      });
    });
  }
  on(key, callback) {
    this.actions.set(key, callback);
  }
  watch() {
    const rl = readline.createInterface(stdin);
    readline.emitKeypressEvents(stdin, rl);
    if (stdin.isTTY) {
      stdin.setRawMode(true);
      stdin.setEncoding("utf8");
    }
    stdin.on("keypress", this.handleKeyPress);
    return {
      ctrlCPromise: this.watchExitProcess()
    };
  }
  unwatch() {
    if (stdin.isTTY) {
      stdin.setRawMode(false);
    }
    stdin.off("keypress", this.handleKeyPress);
    stdin.pause();
    this.actions.clear();
  }
  handleKeyPress = (_, key) => {
    this.actions.get(key.name)?.(key);
  };
};

// ../cli-site-old/src/bi.ts
init_esm_shims();
import { randomUUID } from "node:crypto";
var sitesBiEvents = (biLogger) => ({
  file: ({
    model,
    action,
    path,
    sectionName,
    oldPath
  }) => {
    void biLogger.report(
      wixCliFileFolderCreatedRenamedDeleted({
        action,
        path,
        sectionName,
        oldPath,
        siteRevision: Number(model.revision)
      })
    );
  },
  codeChanged: (model, fileName) => {
    void biLogger.report(
      wixCliCodeHasBeenChanged({
        fileName,
        siteRevision: Number(model.revision)
      })
    );
  },
  readyForReloadAfterCodeChanged: (model) => {
    void biLogger.report(
      wixCliReadyForReloadAfterCodeChange({
        siteRevision: Number(model.revision)
      })
    );
  },
  messageDisplayed: ({
    message,
    model
  }) => {
    void biLogger.report(
      wixCliCliMessageDisplayed({
        message,
        messageId: randomUUID(),
        siteRevision: Number(model.revision)
      })
    );
  },
  userResponse: ({
    model,
    action,
    message
  }) => {
    void biLogger.report(
      wixCliUserResponseToCliMessage({
        action,
        message,
        messageId: randomUUID(),
        siteRevision: Number(model.revision)
      })
    );
  }
});

// ../cli-site-old/src/dev/sync-all-to-revision.ts
init_esm_shims();
import { rm as rm2 } from "node:fs/promises";

// ../cli-site-old/src/sources/index.ts
init_esm_shims();
import { readdir } from "node:fs/promises";

// ../cli-site-old/src/sources/pages-diff.ts
init_esm_shims();
import { join as join2 } from "node:path";
import { rm, rename } from "node:fs/promises";
async function createPages(projectFolder, pages) {
  await Promise.all(
    pages.map((page) => {
      if (!page.pageId?.path || !page.content) {
        return Promise.resolve();
      }
      return outputFile(join2(projectFolder, page.pageId.path), page.content);
    })
  );
}
async function renamePages(projectFolder, pages) {
  await Promise.all(
    pages.map(async (page) => {
      if (!page.sourcePath?.path || !page.targetPath?.path) {
        return;
      }
      const sourcePath = join2(projectFolder, page.sourcePath.path);
      const targetPath = join2(projectFolder, page.targetPath.path);
      if (await pathExists(targetPath)) {
        return rm(sourcePath, { force: true });
      }
      return rename(sourcePath, targetPath);
    })
  );
}
async function deletePages(projectFolder, pages) {
  await Promise.all(
    pages.map((page) => {
      if (!page.path) {
        return Promise.resolve();
      }
      return rm(join2(projectFolder, page.path), { force: true });
    })
  );
}

// ../cli-site-old/src/sources/index.ts
async function syncPages(model, opts) {
  const pagesFolder = getPagesFolder(model.projectFolder);
  if (!await pathExists(pagesFolder)) {
    throw new CliError({
      code: CliErrorCode.NoPagesDirectoryFound({
        srcDir: getSourceFolder(model.projectFolder)
      }),
      cause: null
    });
  }
  const params = {
    layout: GridAppLayout2.GITHUB,
    sourcePagesPaths: await readdir(pagesFolder),
    targetRevision: model.revision
  };
  const { data } = await httpRequest(
    {
      authState: opts.authState,
      type: "code"
    },
    pagesDiff(params)
  ).catch((e) => {
    throw new CliError({
      code: CliErrorCode.FailedToGetPagesDiff(),
      cause: e,
      info: { ...params }
    });
  });
  await Promise.all([
    createPages(model.projectFolder, data.pagesDiff?.created ?? []),
    renamePages(model.projectFolder, data.pagesDiff?.renamed ?? []),
    deletePages(model.projectFolder, data.pagesDiff?.deleted ?? [])
  ]);
}

// ../cli-site-old/src/dev/sync-all-to-revision.ts
async function syncAllToRevision(model, opts, logger) {
  const logTypesSynced = logger.logSyncingTypesToRevision(model.revision);
  try {
    await syncTypesWithAuth(model, { authState: opts.authState });
    logTypesSynced.success();
  } catch (error) {
    writeCrashReport(getDebugLogFilePath(model.projectFolder), error);
    logTypesSynced.fail();
    await rm2(getTypesDir(model.projectFolder), {
      recursive: true,
      force: true
    }).catch((e) => {
      writeCrashReport(getDebugLogFilePath(model.projectFolder), e);
      logger.logRecoverableFailureToRemoveTypesDir(e);
    });
  }
  const logPagesSynced = logger.logSyncingPagesToRevision(model.revision);
  try {
    await syncPages(model, { authState: opts.authState });
    logPagesSynced.success();
  } catch (error) {
    logPagesSynced.fail();
    throw error;
  }
}

// ../cli-site-old/src/dev/dev.ts
async function dev(initialModel, { biLogger, errorReporter }, {
  https = false,
  tunnel: useTunnel = false
}) {
  let model = initialModel;
  const authState = await authenticate({
    metaSiteId: model.metaSiteId,
    biLogger,
    errorReporter
  });
  const t = createI18nT();
  const logger = createLogger({ t });
  const biEvents = sitesBiEvents(biLogger);
  const server = createVeloCLIServer({ https });
  let gridAppId;
  try {
    gridAppId = await createMutableGridApp(model.projectFolder, {
      authState
    });
  } catch (error) {
    const message = isHttpError(error) && error.response?.data?.message;
    throw new CliError({
      code: CliErrorCode.FailedToCreateGridApp({
        error: message
      }),
      cause: error
    });
  }
  await syncAllToRevision(model, { authState }, logger);
  const { close } = startGridAppUpdater(
    model,
    gridAppId,
    {
      authState,
      onError(error) {
        logger.logNewLine();
        errorReporter.reportError(error);
        writeCrashReport(getDebugLogFilePath(model.projectFolder), error);
        renderSync((0, import_react.createElement)(ErrorViewer, { error }));
      }
    },
    logger,
    biEvents
  );
  const onServerDisconnected = (devEditorUrl) => {
    const message = logger.logNoOpenedTab(devEditorUrl);
    biEvents.messageDisplayed({ model, message });
  };
  const onSyncDevEditorChanges = async (revision) => {
    if (revision !== model.revision) {
      const newModel = { ...model, revision };
      await saveProjectModel(newModel);
      const message = logger.logUpdatedLocalCodeToRevision({
        revision: newModel.revision
      });
      biEvents.messageDisplayed({ message, model });
      await syncAllToRevision(newModel, { authState }, logger);
      model = newModel;
    }
  };
  const openLocalEditor = async (serverPort) => {
    biEvents.userResponse({
      action: "Browser opened",
      message: "Opening the Local Editor",
      model
    });
    const devEditorUrl = getDevEditorUrl(serverPort);
    if (https) {
      await openBrowser(new URL(`https://localhost:${serverPort}`).href);
    } else {
      await openBrowser(devEditorUrl);
    }
  };
  let keyWatcher;
  let tunnel2;
  const getDevEditorUrl = (serverPort) => {
    const url = new URL(model.metaSiteId, getDevEditorBaseUrl());
    if (tunnel2) {
      url.searchParams.append("localEditorDestination", tunnel2.domain);
    } else {
      url.searchParams.append("localPort", serverPort.toString());
    }
    url.searchParams.append("secureSocket", https.toString());
    return url.toString();
  };
  try {
    const { port: serverPort } = await server.serve(gridAppId, {
      getDevEditorUrl
    });
    if (useTunnel) {
      const httpClient = createHttpClient({
        type: "backoffice",
        getAppToken: authState.getAccessToken
      });
      const tunnelClient = new TunnelClient(httpClient);
      tunnel2 = await launchTunnel(serverPort, tunnelClient);
    }
    const devEditorUrl = getDevEditorUrl(serverPort);
    server.on("disconnected", () => onServerDisconnected(devEditorUrl));
    server.on("syncDevEditorChanges", onSyncDevEditorChanges);
    keyWatcher = new KeyWatcher();
    logger.logOpeningBrowser(https);
    await openLocalEditor(serverPort);
    const { ctrlCPromise } = keyWatcher.watch();
    keyWatcher.on("e", () => openLocalEditor(serverPort));
    asyncExitHook(
      async () => {
        await server.close();
        tunnel2?.close();
      },
      { wait: 500 }
    );
    await ctrlCPromise;
  } finally {
    keyWatcher?.unwatch();
    await Promise.all([server.close(), close(), tunnel2?.close()]);
  }
}
export {
  dev
};
//# sourceMappingURL=dev-UIDEVHB2.js.map