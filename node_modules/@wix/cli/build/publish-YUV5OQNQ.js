import { createRequire as _createRequire } from 'node:module';
const require = _createRequire(import.meta.url);
import {
  DeploymentSource,
  deployGridApp,
  getDefaultBranch,
  getDeploymentStatus,
  require_prompts
} from "./chunk-DRTGGSXY.js";
import {
  isSiteNotPublishedError
} from "./chunk-K4EZRW26.js";
import "./chunk-QKXNIB4D.js";
import {
  createLogger,
  httpRequest
} from "./chunk-RNE7RRCK.js";
import {
  createI18nT
} from "./chunk-2G7FRAIA.js";
import "./chunk-CNXKF7E3.js";
import {
  authenticate
} from "./chunk-PAPTRQZR.js";
import "./chunk-EDFOB3LN.js";
import {
  getDeploymentPipelineDescription,
  publishDeployment
} from "./chunk-LZJPV4CP.js";
import {
  DeploymentPipelinesStatus
} from "./chunk-6XRFJZTQ.js";
import "./chunk-E2POOOG2.js";
import "./chunk-OJHDGJWP.js";
import {
  DeploymentOperation
} from "./chunk-DDC4C6V6.js";
import "./chunk-KWG4MUE3.js";
import {
  resolveUrl,
  serializer,
  toURLSearchParams
} from "./chunk-O25O35J2.js";
import {
  writeCrashReport
} from "./chunk-7VND5WMC.js";
import "./chunk-WN3D6AOY.js";
import "./chunk-OH3G6JMX.js";
import "./chunk-W423UTD3.js";
import {
  source_default
} from "./chunk-2K5KKUL3.js";
import "./chunk-YU54OBFT.js";
import "./chunk-XMTHMR2B.js";
import "./chunk-VSMZTFUW.js";
import {
  getDebugLogFilePath
} from "./chunk-2CPXK3HU.js";
import "./chunk-F6DVF5WQ.js";
import "./chunk-GNB7T7J7.js";
import {
  CliError,
  CliErrorCode,
  require_lib
} from "./chunk-CVJG3VZM.js";
import {
  __toESM,
  init_esm_shims
} from "./chunk-PYIAC2GK.js";

// ../cli-site-old/src/publish/index.ts
init_esm_shims();

// ../cli-site-old/src/publish/publish.ts
init_esm_shims();
import { URL } from "node:url";
import { exit } from "node:process";
var import_prompts = __toESM(require_prompts(), 1);
var import_variant = __toESM(require_lib(), 1);

// ../cli-site-old/src/pages-types-client/index.ts
init_esm_shims();

// ../../node_modules/@wix/ambassador-typok-v1-siterevision/build/es/http.impl.js
init_esm_shims();
var _getSiteRevisionRequest = {};
var _getSiteRevisionResponse = {};
function resolveWixTypokV1SiteRevisionServiceUrl(opts) {
  var domainToMappings = {
    "bo._base_domain_": [
      {
        srcPath: "/_serverless/typok",
        destPath: ""
      }
    ],
    "wixbo.ai": [
      {
        srcPath: "/_serverless/typok",
        destPath: ""
      }
    ],
    "wix-bo.com": [
      {
        srcPath: "/_serverless/typok",
        destPath: ""
      }
    ],
    "editor._base_domain_": [
      {
        srcPath: "/_serverless/typok",
        destPath: ""
      }
    ],
    "blocks._base_domain_": [
      {
        srcPath: "/_serverless/typok",
        destPath: ""
      }
    ],
    "create.editorx": [
      {
        srcPath: "/_serverless/typok",
        destPath: ""
      }
    ]
  };
  return resolveUrl(Object.assign(opts, { domainToMappings }));
}
function getSiteRevision(payload) {
  var _a = serializer(_getSiteRevisionRequest, {}), toReq = _a.toJSON, fromReq = _a.fromJSON;
  var fromRes = serializer(_getSiteRevisionResponse, {}).fromJSON;
  function __getSiteRevision(_a2) {
    var host = _a2.host;
    var serializedData = toReq(payload);
    var metadata = {
      entityFqdn: "wix.typok.v1.siterevision",
      method: "GET",
      methodFqn: "wix.typok.v1.SiteRevisionService.GetSiteRevision",
      url: resolveWixTypokV1SiteRevisionServiceUrl({
        protoPath: "/v1/site-revision",
        data: serializedData,
        host
      }),
      params: toURLSearchParams(serializedData),
      transformResponse: fromRes
    };
    return metadata;
  }
  __getSiteRevision.fromReq = fromReq;
  __getSiteRevision.__isAmbassador = true;
  return __getSiteRevision;
}

// ../cli-site-old/src/pages-types-client/index.ts
var getLatestRevision = async (opts) => {
  try {
    const pagesResponse = await httpRequest(
      {
        type: "editor",
        authState: opts.authState
      },
      getSiteRevision({})
    );
    return pagesResponse.data.siteRevision?.revision ?? null;
  } catch (e) {
    opts.logger.logFailedToGetLatestRevision(e);
  }
  return null;
};

// ../cli-site-old/src/publish/publish.ts
var toBaseSiteUrl = (fullUrl) => {
  const url = new URL(fullUrl);
  return `${url.protocol}//${url.host}${url.pathname}`;
};
async function publish(model, { biLogger, errorReporter }, options) {
  const authState = await authenticate({
    metaSiteId: model.metaSiteId,
    biLogger,
    errorReporter
  });
  const t = createI18nT();
  const logger = createLogger({ t });
  const defaultBranchName = await getDefaultBranch(
    (e) => writeCrashReport(getDebugLogFilePath(model.projectFolder), e)
  );
  const whatToPublish = options.source ? { value: options.source } : await (0, import_prompts.default)(
    {
      type: "select",
      name: "value",
      message: logger.t("publish_command.prompt_what_to_publish"),
      choices: [
        {
          title: source_default.cyan(
            defaultBranchName ? logger.t(
              "publish_command.prompt_what_to_publish_choice_remote",
              {
                branchName: defaultBranchName
              }
            ) : logger.t(
              "publish_command.prompt_what_to_publish_choice_remote_fallback"
            )
          ),
          value: "remote"
        },
        {
          title: source_default.cyan(
            logger.t("publish_command.prompt_what_to_publish_choice_local")
          ),
          value: "local"
        }
      ]
    },
    {
      onCancel: () => {
        logger.logAborting();
        exit(
          130
          /* SIGINT */
        );
      }
    }
  );
  const deploymentSource = whatToPublish.value === "local" ? DeploymentSource.local() : DeploymentSource.remote({});
  let preview;
  const logPreviewed = logger.logPreviewing();
  try {
    preview = await deployGridApp({
      model,
      operation: DeploymentOperation.RC,
      source: deploymentSource,
      authState
    });
    logPreviewed.success();
  } catch (err) {
    if (isSiteNotPublishedError(err)) {
      logPreviewed.stop();
      logger.logPreviewUnsupported();
    } else {
      logPreviewed.fail();
      throw err;
    }
  }
  const latestRevision = await getLatestRevision({ authState, logger });
  const currentRevision = preview?.deployedRevision ?? model.revision;
  logger.logPublishRevision({
    branchName: defaultBranchName,
    isLocalDeployment: (0, import_variant.isType)(deploymentSource, DeploymentSource.local),
    currentRevision,
    latestRevision,
    preview
  });
  const shouldPublish = options.approvePreview ? { value: true } : await (0, import_prompts.default)({
    type: "confirm",
    name: "value",
    message: logger.t("publish_command.prompt_continue_with_publish"),
    initial: true
  });
  const publish2 = shouldPublish.value;
  if (publish2) {
    const logDeployed = logger.logDeploying();
    const deployment = preview ?? await deployGridApp({
      model,
      authState,
      operation: DeploymentOperation.GA,
      source: deploymentSource
    });
    const { deploymentId, deploymentUrl, isPublishPipelineDeployment } = deployment;
    let deploymentStatus;
    try {
      deploymentStatus = !isPublishPipelineDeployment ? DeploymentPipelinesStatus.SUCCESS : await getDeploymentStatus({
        deploymentId,
        authState
      });
    } catch (err) {
      logDeployed.fail();
      throw err;
    }
    if (deploymentStatus === DeploymentPipelinesStatus.SUCCESS) {
      logDeployed.success();
    }
    let skipPipelineCheck;
    if (deploymentStatus === DeploymentPipelinesStatus.ERROR) {
      logDeployed.fail();
      try {
        const { data } = await httpRequest(
          {
            type: "editor",
            authState
          },
          getDeploymentPipelineDescription({
            deploymentId: deployment.deploymentId,
            deploymentPipelinesIds: ["5c696513-2584-4f19-ae0f-a559dd649482"]
            // Velo Pipeline ID
          }),
          { retries: 2 }
        );
        if (data.pipelinesDescription?.length) {
          const { pipelinesDescription } = data;
          logger.logPipelineErrorInformation({ pipelinesDescription });
        }
      } catch (err) {
        throw new CliError({
          code: CliErrorCode.FailedToGetDeploymentPipelineDescription(),
          cause: err
        });
      }
      logger.logForceDeployWarning();
      const shouldSkipPipelineCheck = options.force ? { value: true } : await (0, import_prompts.default)({
        type: "confirm",
        name: "value",
        message: t("publish_command.prompt_publish_with_error"),
        initial: true
      });
      skipPipelineCheck = shouldSkipPipelineCheck.value;
    }
    if (deploymentStatus === DeploymentPipelinesStatus.SUCCESS || skipPipelineCheck) {
      const logPublished = logger.logPublishing();
      try {
        await httpRequest(
          {
            type: "editor",
            authState
          },
          publishDeployment({
            deploymentId,
            skipPipelineCheck
          }),
          { retries: 2 }
        );
      } catch (err) {
        logPublished.fail();
        throw new CliError({
          code: CliErrorCode.FailedToPublishDeployment(),
          cause: err
        });
      }
      logPublished.success({
        siteUrl: toBaseSiteUrl(deploymentUrl)
      });
    }
  } else {
    logger.logPublishAborted();
  }
}
export {
  publish
};
//# sourceMappingURL=publish-YUV5OQNQ.js.map